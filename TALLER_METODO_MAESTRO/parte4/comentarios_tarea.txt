 IMPORTANTE: SE DEBE DE ABRIR LA TERMINAL DE VSCODE Y ESPECIFICAR EL LUGAR EN EL QUE SE ENCUENTRA LA CARPETA CON LOS ARCHIVOS
 Y LUEGO INGRESAR EL NOMBRE DEL ARCHIVO DE PYTHON (buscar_personas) PARA ASI CORRER EL C√ìDIGO. üë©üèº‚Äçüíª




1. DISE√ëO DEL ALGORITMO

Objetivo: Buscar una persona espec√≠fica por su nombre en una base de datos desordenada.

Estrategia: Como los registros est√°n desordenados, no se puede usar b√∫squeda binaria. Se implementa una b√∫squeda lineal, revisando cada registro uno por uno.

Pseudoc√≥digo:
Algoritmo BuscarPorNombre(nombre_buscado):
    Conectar a la base de datos
    Ejecutar consulta: SELECT * FROM personas WHERE nombre = nombre_buscado
    Si hay resultados:
        Mostrar los datos de la persona
    Si no hay resultados:
        Mostrar "No se encontr√≥ la persona"
    Cerrar conexi√≥n

2. FORMULACI√ìN DE LA RECURRENCIA

 El algoritmo se implementa de forma recursiva, dividiendo los registros en dos partes.

Recurrencia:
T(n) = 2 * T(n/2) + O(1)

Esto representa dos llamadas recursivas sobre la mitad de los datos, con un costo constante para dividir 
y combinar.

3. RESOLUCI√ìN DE LA RECURRENCIA (M√âTODO MAESTRO)

Forma general:
T(n) = a * T(n/b) + f(n)

Identificaci√≥n de par√°metros:
a = 2
b = 2
f(n) = O(1)

C√°lculo:
log_b a = log_2 2 = 1
n^d = n^0 = 1
n^{log_b a} = n^1

Comparaci√≥n:
f(n) = O(n^0) < n^{log_b a} = n^1

Caso aplicado: Caso 1 del M√©todo Maestro

Resultado:
T(n) = Œò(n^{log_b a}) = Œò(n)

4. AN√ÅLISIS DEL M√âTODO MAESTRO

Valores identificados:
a = 2
b = 2
d = 0

Comparaci√≥n:
n^d = n^0 = 1
n^{log_b a} = n^1

Caso aplicado: Caso 1

Complejidad temporal del algoritmo:
T(n) = Œò(n)

INTERPRETACI√ìN FINAL

El algoritmo tiene una complejidad lineal O(n), lo cual es coherente con una b√∫squeda secuencial sobre 
registros desordenados. Aunque se puede estructurar de forma recursiva, su rendimiento sigue siendo 
proporcional al n√∫mero de registros, ya que cada uno debe ser evaluado.

Este an√°lisis demuestra c√≥mo el M√©todo Maestro permite evaluar el comportamiento temporal de algoritmos 
recursivos y c√≥mo la eficiencia depende del enfoque de dise√±o aplicado.




